<meta name='viewport' content='width=device-width, initial-scale=1'/><!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Dungeon 27 — Prototype</title>
<style>
  /* ========== БАЗОВАЯ СТИЛИСТИКА ========== */
  :root{
    --bg:#0b0c10;
    --panel:#121316;
    --accent:#caa34a;
    --muted:#bfc4c9;
    --danger:#d9534f;
    --success:#5cb85c;
    --glass: rgba(255,255,255,0.03);
    --ui-size: 1.0rem;
  }
  html,body{height:100%;margin:0;background:linear-gradient(#060607,#0b0c10);font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .app{height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;color:var(--muted);overflow:hidden}
  /* ========== МЕНЮ (псевдо-3D дверь) ========== */
  .menu-scene{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;perspective:1200px;background:linear-gradient(180deg,#021 #001 40%, #000 100%);}
  .door-wrap{width:85vmin;max-width:600px;height:85vmin;max-height:600px;transform-style:preserve-3d;transition:transform 1s cubic-bezier(.2,.9,.3,1);}
  .door{
    width:100%;height:100%;position:relative;transform-style:preserve-3d;
    display:flex;align-items:center;justify-content:center;
  }
  .door .panel{
    width:70%;height:90%;background:linear-gradient(#3b2f23,#2b1e15);border-radius:8px;box-shadow:inset 0 8px 24px rgba(0,0,0,.6),0 20px 40px rgba(0,0,0,.7);
    position:relative;transform:translateZ(60px);
    display:flex;align-items:center;justify-content:center;flex-direction:column;
    color:var(--accent);
  }
  .door .knob{width:36px;height:36px;background:gold;border-radius:50%;box-shadow:0 4px 8px rgba(0,0,0,.5);position:absolute;right:8%;top:50%;}
  .door .orn{position:absolute;left:6%;top:10%;font-size:1.2rem;color:rgba(255,255,255,.06)}
  .play-btn{
    margin-top:18px;padding:14px 28px;border-radius:10px;border:none;background:linear-gradient(180deg,var(--accent),#a67d2b);color:#111;font-weight:700;font-size:1.1rem;
    transform:translateZ(90px);box-shadow:0 8px 24px rgba(0,0,0,.6);
    touch-action: manipulation;
  }
  .credits{position:absolute;bottom:18px;left:12px;color:rgba(255,255,255,.12);font-size:.85rem}
  /* door open state */
  .menu-scene.open .door-wrap{transform:translateZ(-240px) rotateX(18deg) scale(.7);}
  .menu-scene.open .door .panel{transform:translateZ(-120px) rotateY(70deg);opacity:.08;}
  /* camera fly in overlay */
  .fly-overlay{position:absolute;inset:0;background:radial-gradient(circle at 50% 40%, rgba(255,255,255,.06), transparent 30%);pointer-events:none;opacity:0;transition:opacity .8s;}
  .menu-scene.open .fly-overlay{opacity:1}
  /* ========== ИГРОВОЙ UI ========== */
  .game-screen{width:100%;height:100%;display:none;flex-direction:column;align-items:center;justify-content:flex-start;position:relative;padding:12px;box-sizing:border-box}
  .game-header{width:100%;display:flex;justify-content:space-between;align-items:center;gap:8px}
  .hud{display:flex;gap:8px;align-items:center}
  .stat{background:var(--glass);padding:8px 12px;border-radius:10px;font-size:.95rem}
  .big-btn{padding:12px 18px;border-radius:12px;border:none;background:linear-gradient(180deg,#efefef,#ddd);font-weight:700;touch-action:manipulation}
  .scene-area{width:100%;max-width:900px;height:60vh;background:linear-gradient(#111,#0b0c10);margin-top:12px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.6);position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center}
  .room { width:88%;height:88%;border-radius:8px;background:linear-gradient(#15151a,#0f1012);position:relative;display:flex;align-items:center;justify-content:center;flex-direction:column;color:var(--muted); }
  .room .room-info{position:absolute;top:8px;left:8px;font-size:.9rem}
  .room .center-object{width:120px;height:120px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;font-size:1rem;text-align:center;padding:8px}
  .actions{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:10px}
  .action-btn{padding:12px 18px;border-radius:10px;border:none;background:var(--accent);color:#111;font-weight:700;min-width:100px;touch-action:manipulation}
  .log{position:absolute;bottom:12px;left:12px;right:12px;max-height:26%;overflow:auto;background:rgba(0,0,0,.35);padding:8px;border-radius:8px;font-size:.9rem}
  .next-room{position:absolute;right:12px;bottom:12px;padding:12px 14px;border-radius:10px;background:linear-gradient(#3a3a3a,#242424);color:var(--muted);border:none}
  /* inventory / panels */
  .sidebar{position:absolute;top:12px;right:12px;width:220px;max-width:40%;background:rgba(0,0,0,.25);padding:8px;border-radius:10px}
  .inv-list{display:flex;flex-direction:column;gap:6px;max-height:40vh;overflow:auto}
  .inv-item{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px;display:flex;justify-content:space-between;align-items:center;font-size:.9rem}
  .small-btn{padding:6px 8px;border-radius:6px;border:none;background:#222;color:var(--muted);font-size:.85rem}
  /* responsive: mobile */
  @media (max-width:600px){
    :root{--ui-size: .9rem}
    .door-wrap{width:92vmin;height:92vmin}
    .sidebar{position:static;width:100%;max-width:none;margin-top:8px;border-radius:8px}
    .scene-area{height:54vh}
    .action-btn{min-width:72px;padding:10px 12px;font-size:.95rem}
    .room .center-object{width:86px;height:86px;font-size:.95rem}
  }
  /* tiny UX niceties */
  .message { padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:6px }
  .loot { color:var(--accent); font-weight:700 }
</style>
</head>
<body>
<div class="app">

  <!-- MENU -->
  <div id="menu" class="menu-scene">
    <div class="door-wrap">
      <div class="door">
        <div class="panel">
          <div style="font-size:1.6rem">DUNGEON 27</div>
          <div style="font-size:.9rem;opacity:.9">Подземелье — 27 этажей</div>
          <button id="playBtn" class="play-btn" aria-label="Play">PLAY</button>
        </div>
        <div class="orn">Готов?</div>
        <div class="knob"></div>
      </div>
    </div>
    <div class="fly-overlay"></div>
    <div class="credits">Prototype — HTML/CSS/JS • Адаптировано для мобильных</div>
  </div>

  <!-- GAME -->
  <div id="game" class="game-screen" role="main" aria-hidden="true">
    <div class="game-header" style="width:100%;max-width:900px">
      <div class="hud">
        <div class="stat" id="hpStat">HP: 100</div>
        <div class="stat" id="dmgStat">DMG: 8</div>
        <div class="stat" id="critStat">CRIT: 10%</div>
        <div class="stat" id="missStat">MISS: 5%</div>
      </div>
      <div style="display:flex;gap:8px">
        <button id="saveBtn" class="big-btn" title="Сохранить">Сохранить</button>
        <button id="resetBtn" class="big-btn" title="Новый прогресс">Новый</button>
      </div>
    </div>

    <div class="scene-area" aria-live="polite">
      <div class="room" id="room">
        <div class="room-info" id="roomInfo">Этаж 1 • Комната 1</div>
        <div class="center-object" id="centerObj">Загрузка...</div>

        <div class="actions" id="actionsArea" style="margin-top:12px;"></div>

        <button id="nextRoomBtn" class="next-room" style="display:none">→ Следующая комната</button>

        <div class="log" id="log"></div>

        <div class="sidebar" id="sidebar">
          <div style="font-weight:700;margin-bottom:6px">Инвентарь</div>
          <div class="inv-list" id="invList"></div>
          <div style="margin-top:8px;display:flex;gap:6px">
            <button id="useHPBtn" class="small-btn">Испить зелье (+30HP)</button>
            <button id="dropAllBtn" class="small-btn">Очистить</button>
          </div>
        </div>

      </div>
    </div>
  </div>

</div>

<script>
/* ========= GAME PROTOTYPE JS =========
   Реализация:
   - Меню с CSS-анимацией двери и "влетом"
   - Генерация 27 этажей × 10 комнат
   - Типы комнат: enemy/chest/light/darkmerchant/trap/empty
   - Простая боевая логика: атака/защита/уклонение, шансы промаха/крита
   - Лут: soulStone/item/gold + сообщения
   - Инвентарь: add/remove + UI
   - Сохранение/загрузка в localStorage
   - Touch-friendly: touchstart/touchend handlers
*/

/* ---------- Конфигурация ---------- */
const CONFIG = {
  FLOORS: 27,
  ROOMS_PER_FLOOR: 10,
  STARTING_PLAYER: {
    hp: 100,
    maxHp: 100,
    dmg: 8,
    critChance: 10, // %
    missChance: 5,  // %
    gold: 0,
    soulStones: 0,
  },
  ROOM_TYPES: [
    { id: 'enemy', weight: 35 },
    { id: 'chest', weight: 18 },
    { id: 'light', weight: 10 },
    { id: 'darkmerchant', weight: 8 },
    { id: 'trap', weight: 12 },
    { id: 'empty', weight: 17 }
  ],
  ITEM_POOL: [
    // пример предметов
    { id: 'rusty_sword', name: 'Ржавый меч', type:'weapon', dmg: 3, rarity:'common' },
    { id: 'iron_sword', name: 'Железный меч', type:'weapon', dmg: 6, rarity:'uncommon' },
    { id: 'steel_sword', name: 'Стальной меч', type:'weapon', dmg: 10, rarity:'rare' },
    { id: 'leather_armor', name: 'Кожаная броня', type:'armor', hp: 10, rarity:'common' },
    { id: 'ring_luck', name: 'Кольцо удачи', type:'accessory', crit: 5, rarity:'uncommon' },
    { id: 'potion_small', name: 'Малое зелье', type:'consumable', heal: 30, rarity:'common' }
  ],
  STORAGE_KEY: 'dungeon27_save_v1'
};

/* ---------- Утилиты ---------- */
// случайное целое [min,max]
function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
// случайный элемент с весами
function weightedChoice(arr){
  const total = arr.reduce((s,i)=>s+(i.weight||1),0);
  let r = Math.random()*total;
  for(const it of arr){
    r -= (it.weight||1);
    if(r<=0) return it;
  }
  return arr[arr.length-1];
}
// клонирование структур
function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
// формат % -> строка
function pct(n){ return Math.round(n) + '%'; }

/* ---------- Состояние игры ---------- */
let state = {
  floor: 1,
  roomIndex: 1, // 1..ROOMS_PER_FLOOR
  player: clone(CONFIG.STARTING_PLAYER),
  inventory: [], // массив itemId / item objects
  rooms: {}, // кеш сгенерированных комнат: rooms["floor-roomIndex"] = {type, cleared, enemy, loot}
  log: []
};

/* ---------- Элементы DOM ---------- */
const menuEl = document.getElementById('menu');
const playBtn = document.getElementById('playBtn');
const gameEl = document.getElementById('game');
const roomInfoEl = document.getElementById('roomInfo');
const centerObjEl = document.getElementById('centerObj');
const actionsArea = document.getElementById('actionsArea');
const nextRoomBtn = document.getElementById('nextRoomBtn');
const logEl = document.getElementById('log');
const invListEl = document.getElementById('invList');
const hpStat = document.getElementById('hpStat');
const dmgStat = document.getElementById('dmgStat');
const critStat = document.getElementById('critStat');
const missStat = document.getElementById('missStat');
const saveBtn = document.getElementById('saveBtn');
const resetBtn = document.getElementById('resetBtn');
const useHPBtn = document.getElementById('useHPBtn');
const dropAllBtn = document.getElementById('dropAllBtn');

/* ---------- ИНИЦИАЛИЗАЦИЯ МЕНЮ ---------- */
playBtn.addEventListener('touchstart', onPlay, {passive:true});
playBtn.addEventListener('click', onPlay);

function onPlay(e){
  // "Открыть дверь" — CSS класс
  menuEl.classList.add('open');
  // через 900ms переключаемся в игровую сцену (камерный "влет")
  setTimeout(()=> {
    menuEl.style.display = 'none';
    gameEl.style.display = 'flex';
    gameEl.setAttribute('aria-hidden','false');
    loadGame(); // загружаем прогресс или стартуем новый
    renderRoom();
  }, 900);
}

/* ---------- ГЕНЕРАЦИЯ КОМНАТ ---------- */
function getRoomKey(floor, roomIndex){ return `${floor}-${roomIndex}`; }

function genRoom(floor, idx){
  // При генерации учитываем сложность этажа
  const type = weightedChoice(CONFIG.ROOM_TYPES).id;
  const key = getRoomKey(floor, idx);
  const room = { type, cleared:false, visited:false, loot: null, enemy: null };

  if(type === 'enemy'){
    // создаём врага с характеристиками, зависящими от этажа
    const base = 5 + Math.floor(floor * 1.6);
    room.enemy = {
      hp: randInt(base+6, base+12),
      maxHp: 0, // заполнится
      dmg: randInt( Math.max(2,Math.floor(base/2)), Math.max(3,Math.floor(base/1.2)) ),
      critChance: randInt(5, 10 + Math.floor(floor/3)),
      missChance: randInt(3, 12),
    };
    room.enemy.maxHp = room.enemy.hp;
  } else if (type === 'chest'){
    // сгенерируем базовый лут
    room.loot = generateLoot(floor);
  } else if (type === 'trap'){
    // триггерится при входе
    room.loot = null;
  } else if (type === 'darkmerchant'){
    // торговец предлагает 1-2 предмета
    room.merchant = {
      goods: pickGoodsForFloor(floor)
    };
  }
  return room;
}

function pickGoodsForFloor(floor){
  const goods = [];
  // Чем выше этаж, тем лучше вероятность рарити
  const picks = randInt(1,2);
  for(let i=0;i<picks;i++){
    // берем случайный предмет, с вероятностью редкости
    let item = clone(CONFIG.ITEM_POOL[randInt(0, CONFIG.ITEM_POOL.length-1)]);
    // небольшая рандомизация стата
    if(item.dmg) item.dmg += Math.floor(floor/4);
    if(item.hp) item.hp += Math.floor(floor/3);
    if(item.crit) item.crit += Math.floor(floor/6);
    goods.push(item);
  }
  return goods;
}

/* ---------- ЛУТ ---------- */
function generateLoot(floor){
  // l: soulStone chance grows with floor; gold scales too; item occasionally
  const soulChance = Math.min(45, 10 + floor); // up to 45%
  const itemChance = Math.min(35, 8 + Math.floor(floor/2));
  const gold = randInt(5 + floor*2, 20 + floor*6);
  const soul = Math.random()*100 < soulChance ? 1 : 0;
  const item = Math.random()*100 < itemChance ? clone(CONFIG.ITEM_POOL[randInt(0, CONFIG.ITEM_POOL.length-1)]) : null;
  return { gold, soul, item };
}

/* ---------- РЕНДЕР И UI ---------- */
function renderHUD(){
  hpStat.textContent = `HP: ${state.player.hp}/${state.player.maxHp || state.player.hp}`;
  dmgStat.textContent = `DMG: ${state.player.dmg}`;
  critStat.textContent = `CRIT: ${pct(state.player.critChance)}`;
  missStat.textContent = `MISS: ${pct(state.player.missChance)}`;
}

function appendLog(msg, cls){
  const el = document.createElement('div');
  el.className = 'message' + (cls ? ' '+cls : '');
  el.innerHTML = msg;
  logEl.prepend(el);
  // ограничение логов
  while(logEl.childElementCount > 60) logEl.removeChild(logEl.lastChild);
}

function renderInventory(){
  invListEl.innerHTML = '';
  if(state.inventory.length === 0){
    invListEl.innerHTML = '<div style="opacity:.6">Пусто</div>';
    return;
  }
  state.inventory.forEach((it, idx)=>{
    const div = document.createElement('div');
    div.className = 'inv-item';
    div.innerHTML = `<div><strong>${it.name}</strong> <span style="opacity:.6">[${it.type}]</span></div>
                     <div style="display:flex;gap:6px">
                       <button class="small-btn" data-idx="${idx}" data-act="use">Использовать</button>
                       <button class="small-btn" data-idx="${idx}" data-act="drop">Выбросить</button>
                     </div>`;
    invListEl.appendChild(div);
  });
  // делегирование обработчиков
  invListEl.querySelectorAll('[data-act]').forEach(btn=>{
    btn.addEventListener('click',e=>{
      const i = Number(btn.dataset.idx);
      const action = btn.dataset.act;
      if(action === 'use') useItem(i);
      if(action === 'drop') removeItem(i);
    });
  });
}

/* ---------- ИНВЕНТАРЬ ---------- */
function addItem(item){
  state.inventory.push(item);
  appendLog(`+ Предмет: <span class="loot">${item.name}</span>`);
  renderInventory();
  saveGame();
}
function removeItem(index){
  const it = state.inventory.splice(index,1)[0];
  appendLog(`- Выброшен предмет: ${it.name}`);
  renderInventory();
  saveGame();
}
function useItem(index){
  const it = state.inventory[index];
  if(!it) return;
  if(it.type === 'consumable' && it.heal){
    state.player.hp = Math.min(state.player.maxHp || CONFIG.STARTING_PLAYER.maxHp, state.player.hp + it.heal);
    appendLog(`Использовано ${it.name}. HP +${it.heal}`);
    state.inventory.splice(index,1);
    renderHUD(); renderInventory(); saveGame();
  } else {
    appendLog(`Нельзя применить ${it.name}`);
  }
}

/* ---------- БОЙ: логика ---------- */

// расчёт попадания: возвращает {hit:true/false, crit:true/false, damage:number}
function performAttack(attacker, defender){
  // промах с учётом attacker.missChance и defender уклонения (будем учитывать как часть defender.missChance)
  const missRoll = Math.random()*100;
  const missThreshold = attacker.missChance || 0;
  if(missRoll < missThreshold){
    return { hit:false, crit:false, damage:0, reason:'miss' };
  }
  // попадание — шанс крита
  const critRoll = Math.random()*100;
  const crit = critRoll < (attacker.critChance || 0);
  // урон = dmg (если crit => *2)
  let dmg = attacker.dmg || 1;
  if(crit) dmg *= 2;
  // небольшая вариативность ±20%
  const variance = 0.8 + Math.random()*0.4;
  dmg = Math.max(1, Math.round(dmg * variance));
  return { hit:true, crit, damage:dmg, reason:'hit' };
}

// Запуск боя с текущим врагом в комнате
let combat = null; // {enemy: {...}, mode:'playerTurn'|'enemyTurn'|'done'}
function startCombat(enemy){
  combat = {
    enemy: clone(enemy),
    mode: 'playerTurn'
  };
  appendLog(`<strong>Враг появился!</strong> HP:${combat.enemy.hp}`);
  renderCombatUI();
}

// Рендер боевых кнопок
function renderCombatUI(){
  actionsArea.innerHTML = '';
  if(!combat) return;
  // атака
  const atk = makeActionButton('Атака', ()=> {
    playerAction('attack');
  });
  const def = makeActionButton('Защита', ()=> {
    playerAction('defend');
  });
  const dodge = makeActionButton('Уклонение', ()=> {
    playerAction('dodge');
  });
  actionsArea.appendChild(atk);
  actionsArea.appendChild(def);
  actionsArea.appendChild(dodge);
  // показываем enemy hp
  centerObjEl.innerHTML = `Враг<br>HP: ${combat.enemy.hp}`;
}

// создание кнопки с touch поддержкой
function makeActionButton(label, handler){
  const btn = document.createElement('button');
  btn.className = 'action-btn';
  btn.textContent = label;
  btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); handler(); }, {passive:false});
  btn.addEventListener('click', handler);
  return btn;
}

// обработка действий игрока
function playerAction(action){
  if(!combat) return;
  // логика: атака наносит урон, защита уменьшает входящий урон на 50% в следующем тике, уклонение повышает шанс промаха противника.
  if(action === 'attack'){
    // игрок атакует
    const res = performAttack(state.player, combat.enemy);
    if(!res.hit){
      appendLog('Вы: <strong>Промах!</strong>');
    } else {
      combat.enemy.hp -= res.damage;
      appendLog(`Вы попали${res.crit?'<strong> (Крит)</strong>':''} — урон: ${res.damage}`);
      if(combat.enemy.hp <= 0){
        appendLog('<span style="color:var(--success)"><strong>Враг повержен!</strong></span>');
        endCombat(true);
        return;
      }
    }
    // враг отвечает
    setTimeout(enemyTurn, 600);
  } else if(action === 'defend'){
    appendLog('Вы заняли защитную стойку — входящий урон уменьшен.');
    // пометим временный бафф
    state.player._defend = true;
    setTimeout(enemyTurn, 600);
  } else if(action === 'dodge'){
    appendLog('Вы пытаетесь уклониться — повышается шанс промаха врага.');
    state.player._dodge = true;
    setTimeout(enemyTurn, 600);
  }
  renderCombatUI();
}

// ход врага
function enemyTurn(){
  if(!combat) return;
  const enemy = combat.enemy;
  // подготовим модификаторы
  let playerMissAdj = state.player._dodge ? (state.player.missChance + 25) : state.player.missChance;
  // когда игрок защищался, уменьшим урон на 50%
  const defend = !!state.player._defend;
  // производим атаку врага
  const res = performAttack(enemy, state.player);
  if(!res.hit){
    appendLog('Враг: <strong>Промах!</strong>');
  } else {
    let dmg = res.damage;
    if(defend) dmg = Math.ceil(dmg * 0.5);
    // наличие предметов или эффектов может менять dmg — можно расширять
    state.player.hp -= dmg;
    appendLog(`Враг наносит ${dmg} урона${res.crit? ' (Крит!)':''}`);
    if(state.player.hp <= 0){
      state.player.hp = 0;
      appendLog('<span style="color:var(--danger)"><strong>Вы погибли...</strong></span>');
      endCombat(false);
      return;
    }
  }
  // сбрасываем временные баффы
  state.player._dodge = false;
  state.player._defend = false;
  // перебрасываем обратно на ход игрока
  renderHUD();
  renderCombatUI();
}

// завершение боя
function endCombat(playerWon){
  if(!combat) return;
  if(playerWon){
    // помечаем комнату очищенной
    const key = getRoomKey(state.floor, state.roomIndex);
    const r = ensureRoom(state.floor, state.roomIndex);
    r.cleared = true;
    // лут + gold + soul
    const loot = r.loot || generateLoot(state.floor);
    if(loot.soul){
      state.player.soulStones = (state.player.soulStones||0) + loot.soul;
      appendLog(`+ Камень души x${loot.soul}`);
    }
    if(loot.gold){
      state.player.gold = (state.player.gold||0) + loot.gold;
      appendLog(`+ Золото: ${loot.gold}`);
    }
    if(loot.item){
      addItem(loot.item);
    }
    // всегда даём сообщение о луте
    appendLog(`<span class="loot">Лут найден</span> — золото:${loot.gold} ${loot.item?('предмет:'+loot.item.name):''}`);
    // показать кнопку next
    nextRoomBtn.style.display = 'block';
    actionsArea.innerHTML = '';
    centerObjEl.innerHTML = 'Комната очищена';
    combat = null;
    saveGame();
  } else {
    // игрок погиб — сброс прогресса на начало этажа, но сохраняем статистику?
    appendLog('Возрождение на текущем этаже с полным HP.');
    // простая механика: возрождаем с полным ХП, но остаёмся в той же комнате (не очищено)
    state.player.hp = state.player.maxHp || CONFIG.STARTING_PLAYER.maxHp;
    renderHUD();
    combat = null;
    actionsArea.innerHTML = '';
    centerObjEl.innerHTML = 'Вы живы, продолжайте';
    saveGame();
  }
}

/* ---------- УПРАВЛЕНИЕ КОМНАТАМИ ---------- */
function ensureRoom(floor, idx){
  const key = getRoomKey(floor, idx);
  if(!state.rooms[key]) state.rooms[key] = genRoom(floor, idx);
  return state.rooms[key];
}

function renderRoom(){
  renderHUD();
  renderInventory();
  actionsArea.innerHTML = '';
  nextRoomBtn.style.display = 'none';
  logEl.innerHTML = ''; // очищаем лог (можно убрать)
  const r = ensureRoom(state.floor, state.roomIndex);
  roomInfoEl.textContent = `Этаж ${state.floor} • Комната ${state.roomIndex}`;
  // маркер посещения
  r.visited = true;

  // визуальное представление центра комнаты
  centerObjEl.innerHTML = '';
  if(r.cleared){
    centerObjEl.innerHTML = 'Очищено';
    nextRoomBtn.style.display = 'block';
    appendLog('Комната уже очищена.');
    return;
  }

  if(r.type === 'enemy'){
    centerObjEl.innerHTML = `Враг`;
    appendLog('Вход: Враг!');
    // сразу начать бой
    startCombat(r.enemy);
  } else if(r.type === 'chest'){
    centerObjEl.innerHTML = `Сундук`;
    const btn = makeActionButton('Открыть сундук', ()=> {
      // открыть и получить лут
      const loot = r.loot || generateLoot(state.floor);
      r.loot = loot;
      r.cleared = true;
      if(loot.soul){ state.player.soulStones = (state.player.soulStones||0) + loot.soul; appendLog(`+ Камень души x${loot.soul}`); }
      if(loot.gold){ state.player.gold = (state.player.gold||0) + loot.gold; appendLog(`+ Золото: ${loot.gold}`); }
      if(loot.item){ addItem(loot.item); }
      centerObjEl.innerHTML = 'Сундук открыт';
      nextRoomBtn.style.display = 'block';
      renderHUD(); saveGame();
    });
    actionsArea.appendChild(btn);
  } else if(r.type === 'light'){
    centerObjEl.innerHTML = `Светлая комната`;
    appendLog('Светлая комната — восстанавливает немного HP.');
    state.player.hp = Math.min(state.player.maxHp || CONFIG.STARTING_PLAYER.maxHp, state.player.hp + Math.floor((state.player.maxHp || CONFIG.STARTING_PLAYER.maxHp) * 0.15));
    r.cleared = true;
    nextRoomBtn.style.display = 'block';
    renderHUD(); saveGame();
  } else if(r.type === 'darkmerchant'){
    centerObjEl.innerHTML = `Тёмный торговец`;
    appendLog('Тёмный торговец предлагает товары.');
    const div = document.createElement('div');
    div.style.display = 'flex'; div.style.flexDirection='column'; div.style.gap='6px';
    r.merchant.goods.forEach((g, i)=>{
      const row = document.createElement('div');
      row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center';
      row.innerHTML = `<div><strong>${g.name}</strong> <span style="opacity:.6">[${g.rarity||'common'}]</span></div>
                       <div style="display:flex;gap:6px">
                         <button class="small-btn" data-buy="${i}">Купить (10G)</button>
                       </div>`;
      div.appendChild(row);
    });
    centerObjEl.appendChild(div);
    // buy handlers
    div.querySelectorAll('[data-buy]').forEach(b=>{
      b.addEventListener('click', ()=>{
        const idx = Number(b.dataset.buy);
        const item = r.merchant.goods[idx];
        const cost = 10 + (item.rarity === 'rare' ? 35 : (item.rarity === 'uncommon'?18:0));
        if((state.player.gold||0) < cost){
          appendLog('Недостаточно золота.');
          return;
        }
        state.player.gold -= cost;
        addItem(item);
        r.cleared = true;
        nextRoomBtn.style.display = 'block';
        renderHUD(); saveGame();
      });
    });
  } else if(r.type === 'trap'){
    centerObjEl.innerHTML = `Ловушка`;
    appendLog('Провалили в ловушку — потеря HP!');
    const dmg = randInt(5 + state.floor, 8 + state.floor*2);
    state.player.hp -= dmg;
    if(state.player.hp <= 0) state.player.hp = 1;
    r.cleared = true;
    nextRoomBtn.style.display = 'block';
    renderHUD(); saveGame();
  } else {
    centerObjEl.innerHTML = `Пустая`;
    appendLog('Пустая комната.');
    r.cleared = true;
    nextRoomBtn.style.display = 'block';
    saveGame();
  }
}

/* ---------- ПЕРЕХОД В СЛЕД. КОМНАТУ ---------- */
nextRoomBtn.addEventListener('touchstart', nextRoom, {passive:true});
nextRoomBtn.addEventListener('click', nextRoom);

function nextRoom(){
  // если комнаты закончились
  if(state.roomIndex >= CONFIG.ROOMS_PER_FLOOR){
    // перейти на следующий этаж
    if(state.floor >= CONFIG.FLOORS){
      appendLog('<strong>Вы прошли подземелье! (prototype)</strong>');
      // сбросим или остановим
      return;
    }
    state.floor++;
    state.roomIndex = 1;
    appendLog(`Поднялись на этаж ${state.floor}`);
  } else {
    state.roomIndex++;
  }
  renderRoom();
  saveGame();
}

/* ---------- СОХРАНЕНИЕ / ЗАГРУЗКА ---------- */
function saveGame(){
  try{
    const st = clone(state);
    localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(st));
    appendLog('Прогресс сохранён.');
  }catch(e){
    console.warn('Save failed', e);
  }
}
function loadGame(){
  const raw = localStorage.getItem(CONFIG.STORAGE_KEY);
  if(raw){
    try{
      const parsed = JSON.parse(raw);
      // минимальная валидация
      if(parsed && parsed.player && parsed.floor){
        state = parsed;
        appendLog('Прогресс загружен.');
        // ensure maxHp presence
        if(!state.player.maxHp) state.player.maxHp = CONFIG.STARTING_PLAYER.maxHp || 100;
        renderHUD(); renderInventory();
        return;
      }
    }catch(e){ console.warn('Load failed', e); }
  }
  // иначе стартовать новый
  startNewGame();
}
function startNewGame(){
  state = {
    floor: 1,
    roomIndex: 1,
    player: clone(CONFIG.STARTING_PLAYER),
    inventory: [],
    rooms: {},
    log: []
  };
  state.player.maxHp = CONFIG.STARTING_PLAYER.maxHp || 100;
  appendLog('Новая игра — Удачи!');
  renderHUD(); renderInventory();
  saveGame();
}

/* ---------- Доп. UI кнопки ---------- */
saveBtn.addEventListener('click', saveGame);
resetBtn.addEventListener('click', ()=>{ if(confirm('Начать новую игру? Прогресс будет перезаписан.')){ localStorage.removeItem(CONFIG.STORAGE_KEY); startNewGame(); renderRoom(); } });

useHPBtn.addEventListener('click', ()=>{
  // попытаться использовать первое малое зелье
  const idx = state.inventory.findIndex(it=>it.type==='consumable' && it.heal);
  if(idx === -1){ appendLog('Нет зелья.'); return; }
  useItem(idx);
});

dropAllBtn.addEventListener('click', ()=>{
  if(!confirm('Выбросить все предметы?')) return;
  state.inventory = [];
  renderInventory();
  saveGame();
  appendLog('Инвентарь очищен.');
});

/* ---------- ИНИЦИАЛЬНЫЕ ПАРАМЕТРЫ И ПОДГОТОВКА ПЛЕЙЕРА ---------- */
(function preparePlayerStats(){
  // выставим стартовый maxHp
  if(!state.player.maxHp) state.player.maxHp = CONFIG.STARTING_PLAYER.maxHp || 100;
})();

/* ---------- КОМАНДЫ ДЛЯ РАЗРАБОТЧИКА (консоль) ---------- */
window._DUN = {
  state,
  save: saveGame,
  load: loadGame,
  new: startNewGame,
  genRoom
};

/* ---------- ЗАПУСК (если меню пропустить) ---------- */
document.addEventListener('DOMContentLoaded', ()=>{
  // mobile optimizations: disable double-tap zoom
  document.addEventListener('touchstart', ()=>{}, {passive:true});
});
</script>
</body>
</html>
